Brute Force Approach
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        sol = 0
        for i in range(len(s)):
            hs = set()
            for j in range(i, len(s)):
                if s[j] not in hs:
                    hs.add(s[j])
                else:
                    break
            sol = max(sol, len(hs))
        return sol

Time Complexity: O(n^2)
Space Complexity: O(k)

------------------------------------------------------

Set Approach
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        sol = 0
        hs = set()
        l = 0
        r = 0
        

        while r < len(s):
            if s[r] not in hs:
                hs.add(s[r])
            else:
                while s[r] in hs:
                    hs.remove(s[l])
                    l+=1
                hs.add(s[r])
            sol = max(sol, r-l+1)
            r+=1

        return sol
0 <= s.length <= 1000
s may consist of printable ASCII characters.
Time Complexity: O(n)
Space Comlexity: O(m) where m is unique characters in window
