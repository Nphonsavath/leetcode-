217. Contains Duplicate: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
  IDEA: Add to hashmap/hashset to keep track of if it appeared and check

242. Valid Anagram: An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
  IDEA: Can use hashmap to keep track of all the letters that appear, or use array and increment index of ascii value and decrement index of ascii to ensure it is at 0 or not

1. Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
  IDEA: Clever trick to use hashmap to check if map contains (target number - the value at index i in for loop), if it does return both otherwise add to map

49. Group Anagrams: Given an array of strings strs, group the anagrams together. You can return the answer in any order.
  IDEA: iterate through each string in String[], create a char[] to store each letter and iterate through each character in string as an array, ascii subtraction increment, get the string of that array and if its not a keyyet add it with its value as an arrayList and add get that key and add string, return arrayList with map.values()

20. Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
  IDEA: iterate through string, if open push, if not check if stack empty (that means no matching), peek at top, if the top is an open bracket and the char is a closed bracket they match and pop, if not return false. return stack.isEmpty()

125. Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
  IDEA: convert string to replaceAll non alphanumeric, replace space with empty and make lower, 2 pointer, check if new string is null or length 0 return true, compare L and R until cross
  IDEA: Make Character value at strings index 0 and Length -1, while pointer not crossed check if !Character.isLetterOrDigit(start)) (which means not valid char) increment index 1 and continue until both land on valid char then check if equal after calling toLower

121. Best Time to Buy and Sell Stock: You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
  IDEA: 2 pointers at 0 and 1, while the sell pointer (R) is not past length of array compare the price and if you are buying less than selling calculate profit and Math.max, if not put L to R and always increment R

704. Binary Search: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
  IDEA: Like a dictionary, take half and look in the other. 2 Pointer problem, start and end. while L does not pass right, find mid which is int (L+R)/2. If target > num[mid] that means it is on right to move left = mid + 1, if target < num[mid] means on left so R = 
  mid - 1; else return mid.

347. Top K Frequent Elements: Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
  IDEA: Hashing. Iterate through int[] nums, put in hashmap with key (int) and value (freq). Create bucket which is List<Integer>[] with size (nums.length + 1), itereate through key in map.keySet(), get the freq and if the bucket at the freq is null add arrayList, 
  always add the key to that bucket[freq]. make result int[], iterate through desccending order of bnucket, if its not null iterate through each element in bucket.

206. Reverse Linked LIst: Given the head of a singly linked list, reverse the list, and return the reversed list. 
  IDEA: 2 pointer problem, for curr and prev. Make save head.next node, make head next node point to null sincec it is now tail, make prevHead new Head and head the head.next you saved previously. Recusrively, check if head == null or head.next == null, if not 
  call recusrive on head.next til u hit tail which is now new head, it will go back to tail.prevs node and you will make the next next element that element, and set that elements next to null

21. Merge Two Sorted Lists: You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
  IDEA: Check edge cases if eiter list is empty return the other one. Create solution list, and keep track of head variable. While both lists arent null compare values, move head to smaller value and increment the node in the list and head, once one list is null
  have if to check which is emptied first and continue with thhe entirety of other list.

141. Linked List Cycle: Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. 
Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
  IDEA:Remeber tortise and hare, 2xSlow = Fast, ahve 2 pointers at head. While (fast != null && fast.next != null) increment slow by 1 and fast by 2. if they meet then there is a cycle otherwise false.

238. Product of Array Except Self: Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
  IDEA: use 3 arrays: prefix, postfix, solution. use initial value 1 and put in array then multiply by current value, should be slightly offset, then multiply both arrays together for solution. or multiply entire array and divide by each element if possible.

226. Invert binary tree: Given the root of a binary tree, invert the tree, and return its root.
  IDEA: Recursive. Base case if root == null return root. Call on left, call on right. it will make its way to node with left and right. make temp variable, store right, change right to left, change left to temp, return root.

104. Maximum Depth of a Binary Tree Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
  IDEA: Recursion. The max depth using dfs formula is check if root == null return 0, otherwise int left = maxDepth(nodel.left) and same with right, and you will return 1 + the max of the left and right nodes.

543. Diameter of Binary Tree: Given the root of a binary tree, return the length of the diameter of the tree.The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.
  IDEA: Have helper function, and global result var. usual dfs depth recursion, have max = Math.max(res, left+right) and return depth formula 1+Math.max(left, right)

100. Same Tree: Given the roots of two binary trees p and q, write a function to check if they are the same or not.
  IDEA: what makes them the same? well if they are both null they are equal, then cheeck if they are false if one is null or their values are not equal. otherwise call the recrusive function on left and right and return results &&

15: 3Sum: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.
  IDEA: Sort array to treat as TwoSumII. Check initial conditions null or length < 3. Have big for loop for non pivot element, check if i > 0 && nums[i] == nums[i-1] which means to find new non pivot element that isnt used before, otherwise continue (aka keep trying)
  Set L to i+1, and R to typical num.length -1. iterate while L < R, get target value and check if < 0 move left in or > 0 move right in, otherwise create ArrayList and add in that order [i, l, r], increase L and while L < R and L is same as previous element L ++.  

53. Maximum Subarray: Given an integer array nums, find the sub array with the largest sum, and return its sum.
  IDEA: set max and current vars to nums[0]. iterate from i = 1 to length, your current value will either be the max of (current + nums[i] which is the next element, or if it makes it smaller to restart with the next elemnt nums[i]) then the max is math of (current,max)

