217. Contains Duplicate: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
  IDEA: Add to hashmap/hashset to keep track of if it appeared and check

242. Valid Anagram: An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
  IDEA: Can use hashmap to keep track of all the letters that appear, or use array and increment index of ascii value and decrement index of ascii to ensure it is at 0 or not

1. Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
  IDEA: Clever trick to use hashmap to check if map contains (target number - the value at index i in for loop), if it does return both otherwise add to map

49. Group Anagrams: Given an array of strings strs, group the anagrams together. You can return the answer in any order.
  IDEA: iterate through each string in String[], create a char[] to store each letter and iterate through each character in string as an array, ascii subtraction increment, get the string of that array and if its not a keyyet add it with its value as an arrayList and add get that key and add string, return arrayList with map.values()

20. Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
  IDEA: iterate through string, if open push, if not check if stack empty (that means no matching), peek at top, if the top is an open bracket and the char is a closed bracket they match and pop, if not return false. return stack.isEmpty()

125. Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
  IDEA: convert string to replaceAll non alphanumeric, replace space with empty and make lower, 2 pointer, check if new string is null or length 0 return true, compare L and R until cross
  IDEA: Make Character value at strings index 0 and Length -1, while pointer not crossed check if !Character.isLetterOrDigit(start)) (which means not valid char) increment index 1 and continue until both land on valid char then check if equal after calling toLower

121. Best Time to Buy and Sell Stock: You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
  IDEA: 2 pointers at 0 and 1, while the sell pointer (R) is not past length of array compare the price and if you are buying less than selling calculate profit and Math.max, if not put L to R and always increment R

704. Binary Search: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
  IDEA: Like a dictionary, take half and look in the other. 2 Pointer problem, start and end. while L does not pass right, find mid which is int (L+R)/2. If target > num[mid] that means it is on right to move left = mid + 1, if target < num[mid] means on left so R = 
  mid - 1; else return mid.

347. Top K Frequent Elements: Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
  IDEA: Hashing. Iterate through int[] nums, put in hashmap with key (int) and value (freq). Create bucket which is List<Integer>[] with size (nums.length + 1), itereate through key in map.keySet(), get the freq and if the bucket at the freq is null add arrayList, 
  always add the key to that bucket[freq]. make result int[], iterate through desccending order of bnucket, if its not null iterate through each element in bucket.

206. Reverse Linked LIst: Given the head of a singly linked list, reverse the list, and return the reversed list. 
  IDEA: 2 pointer problem, for curr and prev. Make save head.next node, make head next node point to null sincec it is now tail, make prevHead new Head and head the head.next you saved previously. Recusrively, check if head == null or head.next == null, if not 
  call recusrive on head.next til u hit tail which is now new head, it will go back to tail.prevs node and you will make the next next element that element, and set that elements next to null

21. Merge Two Sorted Lists: You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
  IDEA: Check edge cases if eiter list is empty return the other one. Create solution list, and keep track of head variable. While both lists arent null compare values, move head to smaller value and increment the node in the list and head, once one list is null
  have if to check which is emptied first and continue with thhe entirety of other list.

141. Linked List Cycle: Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. 
Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.
  IDEA:Remeber tortise and hare, 2xSlow = Fast, ahve 2 pointers at head. While (fast != null && fast.next != null) increment slow by 1 and fast by 2. if they meet then there is a cycle otherwise false.

238. Product of Array Except Self: Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
  IDEA: use 3 arrays: prefix, postfix, solution. use initial value 1 and put in array then multiply by current value, should be slightly offset, then multiply both arrays together for solution. or multiply entire array and divide by each element if possible.

226. Invert binary tree: Given the root of a binary tree, invert the tree, and return its root.
  IDEA: Recursive. Base case if root == null return root. Call on left, call on right. it will make its way to node with left and right. make temp variable, store right, change right to left, change left to temp, return root.

104. Maximum Depth of a Binary Tree Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
  IDEA: Recursion. The max depth using dfs formula is check if root == null return 0, otherwise int left = maxDepth(nodel.left) and same with right, and you will return 1 + the max of the left and right nodes.

543. Diameter of Binary Tree: Given the root of a binary tree, return the length of the diameter of the tree.The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.
  IDEA: Have helper function, and global result var. usual dfs depth recursion, have max = Math.max(res, left+right) and return depth formula 1+Math.max(left, right)

100. Same Tree: Given the roots of two binary trees p and q, write a function to check if they are the same or not.
  IDEA: what makes them the same? well if they are both null they are equal, then cheeck if they are false if one is null or their values are not equal. otherwise call the recrusive function on left and right and return results &&

15: 3Sum: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.
  IDEA: Sort array to treat as TwoSumII. Check initial conditions null or length < 3. Have big for loop for non pivot element, check if i > 0 && nums[i] == nums[i-1] which means to find new non pivot element that isnt used before, otherwise continue (aka keep trying)
  Set L to i+1, and R to typical num.length -1. iterate while L < R, get target value and check if < 0 move left in or > 0 move right in, otherwise create ArrayList and add in that order [i, l, r], increase L and while L < R and L is same as previous element L ++.  

53. Maximum Subarray: Given an integer array nums, find the sub array with the largest sum, and return its sum.
  IDEA: set max and current vars to nums[0]. iterate from i = 1 to length, your current value will either be the max of (current + nums[i] which is the next element, or if it makes it smaller to restart with the next elemnt nums[i]) then the max is math of (current,max)

169. Majority Element: Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
  IDEA: use hashmap to keep track of frequency, iterate through nums, put in the valuea and its frequency using map.getOrDefault(map[i], 0) +1 and set max to the current freq (Math.max(map.get(nums[i], max));. after that, iterate through keys using mey.keySet()
  and if the value of the key == max return that solution. 
  FOLLOWUP: O(N) Time O(1) Space: first element starts as majortiy ans=nums[0] count = 1. iterate through int[] starting at 1, if ans != nums[i] decrement count. if statement (count == 0) ans = nums[i] count =1.

78. Subsets: Given an integer array nums of unique elements, return all possible subsets(the power set).The solution set must not contain duplicate subsets. Return the solution in any order.
  IDEA: create helper function with (int  i, int[] nums, currentSubsets, and solution). base case if i >= nums.length add currentSubsets to solution. currentSubsets.add(nums[i]) and call helper on i+1, remove the last element in currentSubsets, and call helperon i+1.

2. Add Two Numbers: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
  IDEA: create solution and cursor initially at node. iterate while l1 || l2 exists or carry != 0. if l1 isnt empty, add that to sum and move forward. same with l2. add carry to sum. get the carry value and next ele. set next node to new node and move current.

19. Remove Nth Node From End of List: Given the head of a linked list, remove the nth node from the end of the list and return its head.
  IDEA: 2 pointer, slow and fast. Make fast n elements ahead of slow, iterate both until fast == null, so that S.next will be the elment to remove. 

1929. Concatenation of Array: Specifically, ans is the concatenation of two nums arrays.
  IDEA:  make array 2*nums.length. iterate throug and solution[i] = nums[i] as well as solution[i]+nums.length = nums[i]. boom.

703. Kth Largest Element in a Stream: Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.
  IDEA:  implement priority queue (min queue default in java). add all nums in int[] nums to pq. in add function add val to pq. trick, keep pq at size k so check if pq.size() > k, if so remove() (which will remove smallest element) and return pq.peek()

572. Subtree of Another Tree: Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.
A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.
  IDEA:  create dfs iterative function (checks if root/subRoot == null, return true since it went through the entire thing, check if root or subRoot == null or root.val != subroot.val return false, call on left and right, return &&) in subTree function
  check root/subRoot == false, call dfs function, return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot)

1046. Last Stone Weight: You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:
If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.
  IDEA: use PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()) as max heap, add all stones to pq. while (pq.size() > 1) poll and compare stones.

215: Kth Largest Element in an Array: Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?
  IDEA: add all nums to pq (which is max heap), for loop where condition is i < k-1, so remove elements so that the one you would remove next would be kth element and return that  one

973: K Closest Points to Origin
  IDEA:  Make priority queue with your own comparator PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (b[0]*b[0]+b[1]*b[1] - (a[0]*a[0]+a[1]*a[1]))). Iterate through int[] points, add them to pq, check size of pq and poll if larger. make int[][] and add.

268: Missing Number
  IDEA:  use logic, since it is missing 1 number from [0, n], the correct sum will be all those added together, minus the nums array will lead to missing number

136: Single Number: Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.
  IDEA: use hashmap, put the value in and use getOrDefault(nums[i], 0) + 1. iterate through keyset, if the keys value == 1 return that key

1299: Replace Elements with Greatest Element on Right Side: Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array.
  IDEA:  iterate array backwards, store the temp variable, replace last elementw ith max initially (-1) and compute new max.
