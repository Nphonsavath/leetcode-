217. Contains Duplicate: Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
  IDEA: Add to hashmap/hashset to keep track of if it appeared and check

242. Valid Anagram: An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
  IDEA: Can use hashmap to keep track of all the letters that appear, or use array and increment index of ascii value and decrement index of ascii to ensure it is at 0 or not

1. Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.
  IDEA: Clever trick to use hashmap to check if map contains (target number - the value at index i in for loop), if it does return both otherwise add to map

49. Group Anagrams: Given an array of strings strs, group the anagrams together. You can return the answer in any order.
  IDEA: iterate through each string in String[], create a char[] to store each letter and iterate through each character in string as an array, ascii subtraction increment, get the string of that array and if its not a keyyet add it with its value as an arrayList and add get that key and add string, return arrayList with map.values()

20. Valid Parentheses: Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
  IDEA: iterate through string, if open push, if not check if stack empty (that means no matching), peek at top, if the top is an open bracket and the char is a closed bracket they match and pop, if not return false. return stack.isEmpty()

125. Valid Palindrome: A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.
  IDEA: convert string to replaceAll non alphanumeric, replace space with empty and make lower, 2 pointer, check if new string is null or length 0 return true, compare L and R until cross
  IDEA: Make Character value at strings index 0 and Length -1, while pointer not crossed check if !Character.isLetterOrDigit(start)) (which means not valid char) increment index 1 and continue until both land on valid char then check if equal after calling toLower

121. Best Time to Buy and Sell Stock: You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
  IDEA: 2 pointers at 0 and 1, while the sell pointer (R) is not past length of array compare the price and if you are buying less than selling calculate profit and Math.max, if not put L to R and always increment R

704. Binary Search: Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
  IDEA: Like a dictionary, take half and look in the other. 2 Pointer problem, start and end. while L does not pass right, find mid which is int (L+R)/2. If target > num[mid] that means it is on right to move left = mid + 1, if target < num[mid] means on left so R = 
  mid - 1; else return mid.

347. Top K Frequent Elements: Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
  IDEA: Hashing. Iterate through int[] nums, put in hashmap with key (int) and value (freq). Create bucket which is List<Integer>[] with size (nums.length + 1), itereate through key in map.keySet(), get the freq and if the bucket at the freq is null add arrayList, 
  always add the key to that bucket[freq]. make result int[], iterate through desccending order of bnucket, if its not null iterate through each element in bucket.
